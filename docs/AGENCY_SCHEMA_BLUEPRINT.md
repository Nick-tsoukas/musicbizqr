# Agency Portal Schema Blueprint

This document defines the future backend schema (Strapi-friendly) for the Agency/Label Portal.

## Overview

The Agency Portal enables labels and management companies to manage multiple artists from a single dashboard, track signals across their roster, and coordinate territorial strategies.

---

## 1. LabelAccount (Organization)

The top-level entity representing a label or management company.

```
LabelAccount {
  id: UUID (primary key)
  name: String (required)
  plan: Enum ['free', 'pro', 'enterprise']
  createdAt: DateTime
  updatedAt: DateTime
}
```

**Indexes:**
- `id` (primary)

**Access Rules:**
- Only authenticated users with membership can access

---

## 2. LabelMember

Associates MBQ users with label accounts and defines their role.

```
LabelMember {
  id: UUID (primary key)
  labelAccountId: UUID (foreign key -> LabelAccount)
  userId: UUID (foreign key -> MBQ User)
  role: Enum ['admin', 'agent', 'analyst', 'viewer']
  createdAt: DateTime
  updatedAt: DateTime
}
```

**Indexes:**
- `labelAccountId` (for roster queries)
- `userId` (for user's orgs lookup)
- Composite: `labelAccountId + userId` (unique)

**Access Rules:**
- Admin: full CRUD on members
- Agent: read-only on members
- Analyst/Viewer: read-only on members

**Role Permissions:**
- **admin**: Full access, manage team, manage roster, all signals
- **agent**: Manage assigned artists, handle signals, create tasks
- **analyst**: View analytics, reports, read-only signals
- **viewer**: Read-only access to everything

---

## 3. LabelRosterBand

Links bands to a label account with metadata.

```
LabelRosterBand {
  id: UUID (primary key)
  labelAccountId: UUID (foreign key -> LabelAccount)
  bandId: UUID (foreign key -> Band)
  tier: Enum ['A', 'B', 'C']
  ownerMemberId: UUID (foreign key -> LabelMember, optional)
  tags: JSON (optional, e.g., { city: 'Austin', genre: 'Rock', region: 'Southwest' })
  createdAt: DateTime
  updatedAt: DateTime
}
```

**Indexes:**
- `labelAccountId` (for roster list)
- `bandId` (for band lookup)
- Composite: `labelAccountId + bandId` (unique)
- `ownerMemberId` (for agent workload)

**Access Rules:**
- Admin: full CRUD
- Agent: read + update tier/owner on assigned bands
- Analyst/Viewer: read-only

---

## 4. LabelSignalEvent (Optional - if storing signals)

Stores computed signals for roster bands. Signals can also be computed on-the-fly from analytics data.

```
LabelSignalEvent {
  id: UUID (primary key)
  labelAccountId: UUID (foreign key -> LabelAccount)
  bandId: UUID (foreign key -> Band)
  signalType: Enum [
    'CITY_CLAIM',
    'NEW_CITY_UNLOCKED',
    'CITY_STACK',
    'MOMENTUM_SURGE',
    'PEAK_HOUR',
    'ENGAGED_SESSIONS',
    'RETURNING_FANS',
    'SHARE_CHAIN',
    'SOURCE_SURGE',
    'AFTER_SHOW_ENERGY',
    'PLATFORM_PULL',
    'MILESTONE_DROP'
  ]
  window: Enum ['2h', '24h', '7d', '30d', 'all']
  score: Integer (0-100)
  payload: JSON (signal-specific data: hero, proof, context, accent)
  createdAt: DateTime
  expiresAt: DateTime (optional, for time-windowed signals)
}
```

**Indexes:**
- `labelAccountId + bandId` (for band signals)
- `labelAccountId + signalType` (for type filtering)
- `labelAccountId + createdAt` (for chronological feed)
- `score` (for triage bucket queries)

**Access Rules:**
- All members: read
- System: write (signals generated by background jobs)

**Scaling Notes (1k roster):**
- With 20 bands × 5 signals avg = 100 active signals
- At 1k roster × 5 signals = 5k signals
- Add TTL/expiration for old signals
- Consider partitioning by labelAccountId for large orgs

---

## 5. LabelSignalHandled

Tracks which signals have been handled by team members.

```
LabelSignalHandled {
  id: UUID (primary key)
  labelAccountId: UUID (foreign key -> LabelAccount)
  bandId: UUID (foreign key -> Band)
  signalId: UUID (foreign key -> LabelSignalEvent, optional)
  signalFingerprint: String (alternative: type + window + createdAt hash)
  handledByMemberId: UUID (foreign key -> LabelMember)
  handledAt: DateTime
  notes: Text (optional)
}
```

**Indexes:**
- `labelAccountId + bandId` (for band handled status)
- `signalId` or `signalFingerprint` (for signal lookup)
- `handledByMemberId` (for agent activity)

**Access Rules:**
- Admin/Agent: create, read
- Analyst/Viewer: read-only

---

## 6. LabelTask

Tasks created from signals or manually for accountability.

```
LabelTask {
  id: UUID (primary key)
  labelAccountId: UUID (foreign key -> LabelAccount)
  bandId: UUID (foreign key -> Band)
  signalId: UUID (foreign key -> LabelSignalEvent, optional)
  ownerMemberId: UUID (foreign key -> LabelMember, optional)
  title: String (required)
  dueAt: DateTime (optional)
  status: Enum ['open', 'done']
  notes: Text (optional)
  createdAt: DateTime
  completedAt: DateTime (optional)
  updatedAt: DateTime
}
```

**Indexes:**
- `labelAccountId + status` (for task lists)
- `labelAccountId + bandId` (for band tasks)
- `ownerMemberId + status` (for agent workload)
- `dueAt` (for overdue queries)

**Access Rules:**
- Admin: full CRUD
- Agent: CRUD on own tasks, read others
- Analyst/Viewer: read-only

---

## Computed Aggregations

### CITY_STACK Detection

City stacks are computed by aggregating signals across the roster:

```sql
SELECT 
  context->>'city' as city,
  COUNT(DISTINCT bandId) as artist_count,
  MAX(score) as top_score
FROM LabelSignalEvent
WHERE labelAccountId = :labelAccountId
  AND signalType = 'CITY_CLAIM'
  AND score >= 75
GROUP BY context->>'city'
HAVING COUNT(DISTINCT bandId) >= 2
ORDER BY artist_count DESC, top_score DESC
```

### Triage Bucket Logic

```javascript
function getTriageBucket(signal) {
  const actionTypes = ['MOMENTUM_SURGE', 'AFTER_SHOW_ENERGY', 'CITY_CLAIM', 'SHARE_CHAIN', 'PEAK_HOUR']
  
  if (signal.score >= 85 && actionTypes.includes(signal.type)) {
    return 'needsAction'
  }
  if (signal.score >= 75) return 'heatingUp'
  if (signal.score >= 55) return 'watching'
  return 'cooling'
}
```

---

## API Endpoints (Suggested)

When swapping mock data for real API, implement these endpoints:

### Authentication
- `POST /api/agency/auth/login` - Authenticate member
- `GET /api/agency/auth/me` - Get current member + org

### Organization
- `GET /api/agency/org` - Get org details
- `GET /api/agency/org/members` - List members

### Roster
- `GET /api/agency/roster` - List roster bands with signals
- `GET /api/agency/roster/:bandId` - Get band details + signals
- `PATCH /api/agency/roster/:bandId` - Update tier, owner
- `POST /api/agency/roster/:bandId/assign` - Assign owner

### Signals
- `GET /api/agency/signals` - List all signals (filterable)
- `GET /api/agency/signals/triage` - Get triage buckets
- `POST /api/agency/signals/:signalId/handle` - Mark handled

### Cities
- `GET /api/agency/cities` - List cities with activity
- `GET /api/agency/cities/:city` - Get city details + artists

### Tasks
- `GET /api/agency/tasks` - List tasks (filterable)
- `POST /api/agency/tasks` - Create task
- `PATCH /api/agency/tasks/:taskId` - Update task
- `DELETE /api/agency/tasks/:taskId` - Delete task

---

## How to Swap mockData with Real API Endpoints

1. **Create API service file**: `utils/agencyPortal/api.js`
   ```javascript
   const API_BASE = '/api/agency'
   
   export async function fetchRoster() {
     const response = await fetch(`${API_BASE}/roster`)
     return response.json()
   }
   // ... other methods
   ```

2. **Update store to use API**:
   - Replace mock imports with API calls
   - Add loading states
   - Add error handling
   - Keep state shape identical for component compatibility

3. **Add authentication**:
   - Replace password gate with real auth
   - Store JWT in httpOnly cookie
   - Add auth middleware

4. **Implement Strapi content types**:
   - Create content types matching schema above
   - Add policies for access control
   - Set up relations between types

5. **Add background jobs**:
   - Signal computation from analytics data
   - Signal expiration/cleanup
   - Notification triggers

---

## Version History

- **V1 (Mock)**: Frontend-only with localStorage persistence
- **V2 (Planned)**: Real backend with Strapi, basic auth
- **V3 (Future)**: Full multi-tenant, SSO, advanced analytics

---

*Document generated for MusicBizQR Agency Portal V1*
